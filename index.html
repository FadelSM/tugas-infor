<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Cosmic Data Odyssey - Deployable on Vercel</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      font-family: 'Orbitron', monospace;
      background: #000516;
      overflow: hidden;
    }
    #canvas {
      display: block;
      width: 100%;
      height: 100vh;
    }
    .ui-overlay {
      position: absolute;
      top: 20px;
      left: 20px;
      z-index: 100;
      color: #00ffff;
      font-size: 1.5rem;
      text-shadow: 0 0 10px #00ffff;
    }
    .btn-launch {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(45deg, #ff0080, #8000ff, #0080ff);
      border: none;
      padding: 20px 40px;
      font-size: 1.5rem;
      font-weight: bold;
      color: white;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 0 30px rgba(255, 0, 128, 0.5);
      transition: all 0.3s ease;
    }
    .btn-launch:hover {
      transform: translateX(-50%) scale(1.1);
      box-shadow: 0 0 50px rgba(255, 0, 128, 0.8);
    }
    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff0080;
      font-size: 2rem;
      text-align: center;
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
    .tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.8);
      color: #00ffff;
      padding: 10px;
      border-radius: 5px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s;
      z-index: 200;
    }
  </style>
</head>
<body>
  <div class="ui-overlay">
    <h1>Cosmic Data Odyssey</h1>
    <p>Watch data particles journey from servers to your device in 3D space!</p>
  </div>
  <div id="loading" class="loading">
    Loading Universe... ðŸŒŒ
  </div>
  <canvas id="canvas"></canvas>
  <button id="launchBtn" class="btn-launch">Launch Data Flow</button>
  <div id="tooltip" class="tooltip"></div>

  <script>
    // Scene, Camera, Renderer
    var scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000516);
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);

    // Controls
    var controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.screenSpacePanning = false;
    controls.minDistance = 5;
    controls.maxDistance = 50;

    // Ambient light and stars
    var ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);
    var starGeometry = new THREE.BufferGeometry();
    var starsVertices = [];
    for (var i = 0; i < 10000; i++) {
      starsVertices.push((Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000, (Math.random() - 0.5) * 2000);
    }
    starGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
    var starMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 1 });
    var stars = new THREE.Points(starGeometry, starMaterial);
    scene.add(stars);

    // Nodes representation
    var nodes = [];
    var nodeMaterials = [
      new THREE.MeshStandardMaterial({ color: 0xff6b6b, emissive: 0xff6b6b, emissiveIntensity: 0.5 }),
      new THREE.MeshStandardMaterial({ color: 0x6bffd5, emissive: 0x6bffd5, emissiveIntensity: 0.5 }),
      new THREE.MeshStandardMaterial({ color: 0x6b6bff, emissive: 0x6b6bff, emissiveIntensity: 0.5 }),
      new THREE.MeshStandardMaterial({ color: 0xffd56b, emissive: 0xffd56b, emissiveIntensity: 0.5 })
    ];
    var nodeLabels = ['Bit-World Servers', 'Cyber ISP Gateway', 'Quantum Router Nexus', 'Digital Soul Device'];

    for (var i = 0; i < 4; i++) {
      var geometry = new THREE.SphereGeometry(2, 32, 32);
      var material = nodeMaterials[i];
      var mesh = new THREE.Mesh(geometry, material);
      mesh.position.set((i - 1.5) * 8, 0, 0);
      scene.add(mesh);
      nodes.push(mesh);

      // Add particle system for each node
      var particleGeometry = new THREE.BufferGeometry();
      var particleVertices = [];
      for (var j = 0; j < 50; j++) {
        particleVertices.push((Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8, (Math.random() - 0.5) * 8);
      }
      particleGeometry.setAttribute('position', new THREE.Float32BufferAttribute(particleVertices, 3));
      var particleMaterial = new THREE.PointsMaterial({ color: nodeMaterials[i].color, size: 0.1, opacity: 0.8, transparent: true });
      var particles = new THREE.Points(particleGeometry, particleMaterial);
      particles.position.copy(mesh.position);
      scene.add(particles);
      nodes.push(particles); // Add particles to nodes array
    }

    // Data packets as moving particles
    var dataPackets = [];
    var dataCurve = new THREE.CatmullRomCurve3([
      new THREE.Vector3(-12, 0, 0),
      new THREE.Vector3(-4, 0, 0),
      new THREE.Vector3(4, 0, 0),
      new THREE.Vector3(12, 0, 0)
    ]);

    function createDataPacket() {
      var geometry = new THREE.SphereGeometry(0.5, 16, 16);
      var material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
      var packet = new THREE.Mesh(geometry, material);
      var position = dataCurve.getPointAt(Math.random());
      packet.position.copy(position);
      packet.userData = { speed: 0.02, t: Math.random() };
      scene.add(packet);
      dataPackets.push(packet);
    }

    // Camera position
    camera.position.set(0, 5, 20);

    // Animation loop
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      stars.rotation.x += 0.0001;
      stars.rotation.y += 0.0001;

      dataPackets.forEach(function(packet) {
        packet.userData.t += packet.userData.speed;
        if (packet.userData.t > 1) packet.userData.t = 0;
        var newPosition = dataCurve.getPointAt(packet.userData.t);
        packet.position.copy(newPosition);
        packet.rotation.x += 0.1;
        packet.rotation.y += 0.1;
      });

      renderer.render(scene, camera);
    }
    animate();

    // Launch button handler
    document.getElementById('launchBtn').addEventListener('click', function() {
      for (var i = 0; i < 20; i++) {
        setTimeout(createDataPacket, i * 100);
      }
      this.style.display = 'none';
    });

    // Hide loading after 2s
    setTimeout(function() {
      document.getElementById('loading').style.display = 'none';
    }, 2000);

    // Tooltip on hover
    renderer.domElement.addEventListener('mousemove', function(event) {
      var mouse = new THREE.Vector2();
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      var raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      var intersects = raycaster.intersectObjects(nodes.filter(function(node) { return !!node.geometry; }));

      var tooltip = document.getElementById('tooltip');
      if (intersects.length > 0) {
        var index = nodes.indexOf(intersects[0].object);
        tooltip.innerHTML = nodeLabels[Math.floor(index / 2)];
        tooltip.style.left = event.clientX + 10 + 'px';
        tooltip.style.top = event.clientY + 10 + 'px';
        tooltip.style.opacity = 1;
      } else {
        tooltip.style.opacity = 0;
      }
    });

    // Resize handler
    window.addEventListener('resize', function() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
